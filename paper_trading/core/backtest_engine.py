"""
Backtesting Engine for Paper Trading
"""

import pandas as pd
import numpy as np
from datetime import datetime, timedelta
from typing import Dict, List, Optional, Tuple
import logging
from .portfolio import VirtualPortfolio, OrderSide
from .data_feed import DataProcessor
from ..strategies import StrategyFactory

logger = logging.getLogger(__name__)


class BacktestEngine:
    """Backtesting engine for trading strategies."""
    
    def __init__(
        self,
        initial_balance: float = 10000.0,
        commission_rate: float = 0.001,
        base_currency: str = "USDT"
    ):
        self.initial_balance = initial_balance
        self.commission_rate = commission_rate
        self.base_currency = base_currency
        
        # Results storage
        self.results = {}
        self.trades_history = []
        self.equity_curve = []
        
        logger.info(f"Backtest engine initialized with {initial_balance} {base_currency}")
    
    def run_backtest(
        self,
        data: pd.DataFrame,
        strategy_name: str,
        strategy_parameters: Dict = None,
        symbol: str = "BTCUSDT",
        start_date: str = None,
        end_date: str = None
    ) -> Dict:
        """
        Run backtest for a strategy.
        
        Args:
            data: OHLCV data
            strategy_name: Name of the strategy
            strategy_parameters: Strategy parameters
            symbol: Trading symbol
            start_date: Start date for backtest
            end_date: End date for backtest
            
        Returns:
            Backtest results
        """
        logger.info(f"Starting backtest for {strategy_name}")
        
        # Filter data by date range
        if start_date:
            data = data[data.index >= start_date]
        if end_date:
            data = data[data.index <= end_date]
        
        if data.empty:
            raise ValueError("No data available for the specified date range")
        
        # Create strategy
        strategy = StrategyFactory.create_strategy(strategy_name, strategy_parameters)
        
        # Create portfolio
        portfolio = VirtualPortfolio(
            initial_balance=self.initial_balance,
            commission_rate=self.commission_rate,
            base_currency=self.base_currency
        )
        
        # Add technical indicators
        data = DataProcessor.add_technical_indicators(data)
        data = DataProcessor.calculate_returns(data)
        
        # Generate signals
        signals = strategy.generate_signals(data)
        
        if signals.empty:
            logger.warning("No signals generated by strategy")
            return self._create_empty_results()
        
        # Execute trades
        self._execute_trades(data, signals, portfolio, symbol, strategy_name)
        
        # Calculate results
        results = self._calculate_results(portfolio, data, symbol)
        
        # Store results
        self.results[strategy_name] = results
        
        logger.info(f"Backtest completed for {strategy_name}")
        return results
    
    def _execute_trades(
        self,
        data: pd.DataFrame,
        signals: pd.DataFrame,
        portfolio: VirtualPortfolio,
        symbol: str,
        strategy_name: str
    ):
        """Execute trades based on signals."""
        for i in range(len(signals)):
            if i >= len(data):
                break
                
            current_price = data['close'].iloc[i]
            signal = signals['signal'].iloc[i]
            reason = signals['reason'].iloc[i]
            strength = signals['strength'].iloc[i]
            
            if signal == 0:
                continue
            
            # Calculate position size
            portfolio_value = portfolio.get_total_equity({symbol: current_price})
            position_size = portfolio.calculate_position_size(
                current_price, 
                portfolio_value,
                risk_per_trade=0.02
            )
            
            # Adjust position size based on signal strength
            position_size *= strength
            
            if position_size < 0.001:  # Minimum position size
                continue
            
            # Place order
            order_side = OrderSide.BUY if signal == 1 else OrderSide.SELL
            order_id = portfolio.place_order(
                symbol=symbol,
                side=order_side,
                quantity=position_size,
                strategy=strategy_name,
                reason=reason
            )
            
            # Execute order
            success = portfolio.execute_order(order_id, current_price)
            
            if success:
                # Update equity history
                portfolio.update_equity_history({symbol: current_price})
                
                # Log trade
                logger.info(f"Trade executed: {order_side.value} {position_size:.6f} {symbol} at {current_price:.2f}")
    
    def _calculate_results(
        self,
        portfolio: VirtualPortfolio,
        data: pd.DataFrame,
        symbol: str
    ) -> Dict:
        """Calculate backtest results."""
        # Get portfolio summary
        current_prices = {symbol: data['close'].iloc[-1]}
        portfolio_summary = portfolio.get_portfolio_summary(current_prices)
        
        # Calculate metrics
        metrics = portfolio.calculate_metrics()
        
        # Get trades and orders
        trades_df = portfolio.get_trades_dataframe()
        orders_df = portfolio.get_orders_dataframe()
        
        # Calculate additional metrics
        additional_metrics = self._calculate_additional_metrics(data, trades_df)
        
        # Combine all results
        results = {
            'strategy_name': 'Unknown',
            'symbol': symbol,
            'start_date': data.index[0].strftime('%Y-%m-%d'),
            'end_date': data.index[-1].strftime('%Y-%m-%d'),
            'total_periods': len(data),
            'portfolio_summary': portfolio_summary,
            'metrics': metrics,
            'additional_metrics': additional_metrics,
            'trades': trades_df,
            'orders': orders_df,
            'equity_curve': portfolio.equity_history
        }
        
        return results
    
    def _calculate_additional_metrics(self, data: pd.DataFrame, trades_df: pd.DataFrame) -> Dict:
        """Calculate additional performance metrics."""
        if trades_df.empty:
            return {}
        
        # Buy and hold comparison
        buy_hold_return = (data['close'].iloc[-1] - data['close'].iloc[0]) / data['close'].iloc[0]
        
        # Win rate by trade type
        buy_trades = trades_df[trades_df['side'] == 'BUY']
        sell_trades = trades_df[trades_df['side'] == 'SELL']
        
        # Average trade size
        avg_trade_size = trades_df['quantity'].mean() if not trades_df.empty else 0
        
        # Trade frequency
        total_days = (data.index[-1] - data.index[0]).days
        trade_frequency = len(trades_df) / total_days if total_days > 0 else 0
        
        return {
            'buy_hold_return': buy_hold_return,
            'buy_hold_return_pct': buy_hold_return * 100,
            'total_trades': len(trades_df),
            'buy_trades': len(buy_trades),
            'sell_trades': len(sell_trades),
            'avg_trade_size': avg_trade_size,
            'trade_frequency': trade_frequency,
            'trades_per_day': trade_frequency
        }
    
    def _create_empty_results(self) -> Dict:
        """Create empty results when no trades are executed."""
        return {
            'strategy_name': 'Unknown',
            'symbol': 'Unknown',
            'start_date': None,
            'end_date': None,
            'total_periods': 0,
            'portfolio_summary': {},
            'metrics': {},
            'additional_metrics': {},
            'trades': pd.DataFrame(),
            'orders': pd.DataFrame(),
            'equity_curve': []
        }
    
    def compare_strategies(
        self,
        data: pd.DataFrame,
        strategies: List[Dict],
        symbol: str = "BTCUSDT"
    ) -> pd.DataFrame:
        """
        Compare multiple strategies.
        
        Args:
            data: OHLCV data
            strategies: List of strategy configurations
            symbol: Trading symbol
            
        Returns:
            Comparison DataFrame
        """
        comparison_results = []
        
        for strategy_config in strategies:
            strategy_name = strategy_config['name']
            parameters = strategy_config.get('parameters', {})
            
            try:
                results = self.run_backtest(data, strategy_name, parameters, symbol)
                
                comparison_results.append({
                    'Strategy': strategy_name,
                    'Total Return %': results['metrics'].get('total_return_pct', 0),
                    'Annualized Return %': results['metrics'].get('annualized_return_pct', 0),
                    'Volatility %': results['metrics'].get('volatility_pct', 0),
                    'Sharpe Ratio': results['metrics'].get('sharpe_ratio', 0),
                    'Max Drawdown %': results['metrics'].get('max_drawdown_pct', 0),
                    'Total Trades': results['additional_metrics'].get('total_trades', 0),
                    'Win Rate %': results['metrics'].get('win_rate_pct', 0),
                    'Final Equity': results['portfolio_summary'].get('total_equity', 0)
                })
                
            except Exception as e:
                logger.error(f"Error running backtest for {strategy_name}: {e}")
                comparison_results.append({
                    'Strategy': strategy_name,
                    'Error': str(e)
                })
        
        return pd.DataFrame(comparison_results)
    
    def get_results(self, strategy_name: str = None) -> Dict:
        """Get backtest results."""
        if strategy_name:
            return self.results.get(strategy_name, {})
        return self.results
    
    def save_results(self, strategy_name: str, filename: str):
        """Save results to file."""
        results = self.get_results(strategy_name)
        if not results:
            logger.warning(f"No results found for strategy: {strategy_name}")
            return
        
        # Save trades
        if not results['trades'].empty:
            trades_file = f"{filename}_trades.csv"
            results['trades'].to_csv(trades_file)
            logger.info(f"Trades saved to {trades_file}")
        
        # Save orders
        if not results['orders'].empty:
            orders_file = f"{filename}_orders.csv"
            results['orders'].to_csv(orders_file)
            logger.info(f"Orders saved to {orders_file}")
        
        # Save equity curve
        if results['equity_curve']:
            equity_df = pd.DataFrame(results['equity_curve'])
            equity_file = f"{filename}_equity.csv"
            equity_df.to_csv(equity_file, index=False)
            logger.info(f"Equity curve saved to {equity_file}")
    
    def clear_results(self):
        """Clear all results."""
        self.results = {}
        self.trades_history = []
        self.equity_curve = []
        logger.info("All results cleared")
